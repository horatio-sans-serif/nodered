#!/usr/bin/env node

var sys        = require("sys")
  , flow       = require("../lib/vendor/flow")
  , Controller = require("../lib/controller").Controller
  , config     = require("../lib/config")
  , logger     = require("../lib/logger")
  , pubsub     = require("../lib/pubsub");

var options = { transports: []
              , redis: { port: 6379
                       , host: '127.0.0.1'
                       , debugMode: false 
                       }
              };

var theController = null
  , transportUriRegex = /^--transport=['"]?(.+):\/\/(.+):(\d+)(?:\?(.+))?\s*$['"]?/
  , redisUriRegex = /^--redis=['"]?(.+?)(?::(\d+))?(?:\/(\d+))?(?:\?debug=(on|off))?['"]?$/;

process.argv.forEach(function (arg) {
  var match;

  if (match = arg.match(/^--name=(.+)/)) {
    global.NODE_NAME = match[1].trim();
  } else if (match = arg.match(transportUriRegex)) {
    var kvp = {};

    (match[4] || '').trim().split(/&/).forEach(
      function (kv) {
        var m = kv.match(/^(.+?)=(.+)$/);
        if (!m) {
          logger.error("MAIN  transport has malformed options: " + arg);
          process.exit(1);
        }
        kvp[m[1]] = m[2];
      });

    options.transports.push({ name: match[1]
                            , ip: match[2]
                            , port: parseInt(match[3], 10) 
                            , options: kvp
                            });
  } else if (match = arg.match(redisUriRegex)) {
    options.redis.host = match[1];

    options.redis.port = match[2] 
                       ? parseInt(match[2], 10) 
                       : 6379;

    if (isNaN(options.redis.port)) {
      logger.error("MAIN  invalid redis port number.");
      process.exit(1);
    }

    options.redis.db = match[3] 
                     ? parseInt(match[3], 10) 
                     : 1;

    if (isNaN(options.redis.db)) {
      logger.error("MAIN  invalid redis db number.");
      process.exit(1);
    }

    options.redis.debugMode = match[4] 
                            ? match[4].toLowerCase() === "on" 
                            : false;
  }
});

if (typeof NODE_NAME == "undefined") {
  logger.error("MAIN  set this node's name with --name='<name>'.");
  process.exit(1);
}

if (options.transports.length == 0) {
  logger.error("MAIN  enable transports with --transport=protocol://ip:port.");
  process.exit(1);
}

options.transports.forEach(function (transport) {
  if (config.SUPPORTED_TRANSPORTS.indexOf(transport.name) == -1) {
    logger.error("MAIN  unknown transport: " + transport.name + ".");
    process.exit(1);
  }
});

logger.info("MAIN/VERSION  " + config.VERSION);
logger.info("MAIN/NAME  " + NODE_NAME);
logger.info("MAIN/TRANSPORTS  " + options.transports.map(
  function (t) { 
    return t.name 
  }).join(', '));
logger.info("MAIN/NODEJS " + process.version);
logger.info("MAIN/REDIS  " + JSON.stringify(options.redis));

setInterval(
  function () {
    if (pubsub.controlClient) {
      try {
        var memUsage = JSON.stringify(process.memoryUsage());
        pubsub.controlClient.hset(key, 'memUsage', memUsage,
          function (err, reply) {
            if (err) logger.error("MAIN  Failed to update local memory usage stat in Redis: " + err);
          });
      } catch (e) {
        // We don't care.
      }
    }
  }, 30000);

pubsub.initRedisClients(options.redis, function () {
  flow.exec(
    function () {
      pubsub.controlClient.incr('nr:nodeid', this);
    },
    function (err, nodeID) {
      if (err) throw err;
      global.NODE_ID = parseInt(nodeID, 10);
      if (isNaN(NODE_ID)) {
        logger.error("MAIN/INIT  Invalid node ID!");
        process.exit(1);
      }
      pubsub.controlClient.zadd('nr:cluster', NODE_ID, NODE_NAME, this);
    },
    function (err, wasAdded) {
      if (err) throw err;
      if (!wasAdded) {
        logger.error("MAIN  " + NODE_NAME + " is not unique in the cluster.");
        process.exit(1);
      }
      this();
    },
    function () {
      pubsub.controlClient.info(this);
    },
    function (err, info) {
      if (err) throw err;

      logger.info("MAIN/REDIS  " + info.redis_version);

      if (info.redis_version < config.MIN_REDIS_VERSION) {
        logger.error("MAIN/REDIS  Redis version too old!");
        process.exit(1);
      }

      var key = 'nr:cluster:' + NODE_ID;
      var now = Date.now();

      pubsub.controlClient.hset(key, 'name', NODE_NAME, this.MULTI());
      pubsub.controlClient.hset(key, 'id', NODE_ID, this.MULTI());
      pubsub.controlClient.hset(key, 'version', config.VERSION, this.MULTI());
      pubsub.controlClient.hset(key, 'nodejsVersion', process.version, this.MULTI());
      pubsub.controlClient.hset(key, 'systemPlatform', process.platform, this.MULTI());
      pubsub.controlClient.hset(key, 'upSince', now, this.MULTI());
      pubsub.controlClient.hset(key, 'clientCount', '0', this.MULTI());

      // e.g. "tcp" => "127.0.0.1:8080"
      for (var i=0, n=options.transports.length; i<n; ++i) {
        var hostPort = options.transports[i].ip + ":" + options.transports[i].port;
        pubsub.controlClient.hset(key, options.transports[i].name, hostPort, this.MULTI());
      }
    },
    function (argsArray) {
      argsArray.forEach(function (args) {
        if (args[0]) throw args[0];
      });

      theController = new Controller(options);
    }
  );
});

function shutdown() {
  flow.exec(
    function removeNodeFromCluster() {
      logger.info("MAIN/SHUTDOWN  removing node from cluster.");
      theController.inShutdown = true;
      pubsub.controlClient.zremrangebyscore('nr:cluster', 
        NODE_ID, NODE_ID, this.MULTI());
      pubsub.controlClient.del('nr:cluster:' + NODE_ID, this.MULTI());
    },
    function unsubscribeLocalSubscribers(argsArray) {
      for (var i=0, n=argsArray.length; i<n; ++i) {
        var args = argsArray[i];
        if (args[0]) throw args[0];    
      }

      logger.info("MAIN/SHUTDOWN  removing local subscribers from any channels.");

      var channels = pubsub.getLocalChannelsWithLocalSubscribers(); 
      if (channels.length == 0) {
        this();
      } else {
        for (var i=0, n=channels.length; i<n; ++i) {
          var channel = channels[i];
          pubsub.controlClient.zremrangebyscore('nr:chan:' + channel, 
            NODE_ID, NODE_ID, this.MULTI());
          if (DEBUG) logger.debug("MAIN/SHUTDOWN  channel: " + channel);
        }
      }
    },
    function removeLocalNicknames(argsArray) {
      if (argsArray) {
        for (var i=0, n=argsArray.length; i<n; ++i) {
          var args = argsArray[i];
          if (args[0]) throw args[0];    
        }
      }

      logger.info("MAIN/SHUTDOWN  removing locally-used nicknames.");
      pubsub.controlClient.zremrangebyscore('nr:nicks', NODE_ID, NODE_ID, this);
    },
    function disconnectAllClientsWithMessage(err, reply) {
      if (err) throw err;

      logger.info("MAIN/SHUTDOWN  cleanly disconnecting all.");
      
      var serializedMessage = JSON.stringify([ "MESSAGE"
                                             , config.SYSTEM_CHANNEL
                                             , { msg:"shutdown" } 
                                             ]) + "\r\n";

      var nicks = Object.getOwnPropertyNames(theController.clients);

      if (nicks.length == 0) {
        logger.info("MAIN/SHUTDOWN  no clients connected.");
        this();
      } else {
        logger.info("MAIN/SHUTDOWN  " + nicks.length + " connected.");

        var toDrain = 0;
        for (var i=0, n=nicks.length; i<n; ++i) {
          var client = theController.clients[nicks[i]];

          if (!client.stream.writable) {
            logger.warn("MAIN/SHUTDOWN  " + client.nickname + "@" + 
              client.stream.remoteAddress + " is not writable.");

            this.MULTI()();
            continue;
          }

          if (client.stream.write(serializedMessage, "utf8")) {
            logger.warn("MAIN/SHUTDOWN  " + client.nickname + "@" + 
              client.stream.remoteAddress + " sent shutdown notice.");

            client.stream.end();
            this.MULTI()();
          } else {
            logger.warn("MAIN/SHUTDOWN  " + client.nickname + "@" + 
              client.stream.remoteAddress + " buffer full... waiting");

            toDrain++;
            client.stream.addListener('drain', function () {
              toDrain--;
              logger.info("MAIN/SHUTDOWN  client drained. left: " + toDrain);
              client.stream.end();
              this.MULTI()();
            });
          }
        }
      }
    },
    function andFinallyExit() {
      logger.info("MAIN/SHUTDOWN  shutdown sequence complete.");
      process.exit(0);
    }
  );
}
  
[ "SIGINT", "SIGKILL", "SIGQUIT", "SIGTERM" ].forEach(
  function (signalName) {
    process.addListener(signalName, 
      function () {
        sys.error("");
        logger.error("MAIN/SIGNAL  " + signalName);
        shutdown();
      });
  });

var uncaughtCount = 0;

process.addListener("uncaughtException", 
  function (err) {
    logger.error("MAIN  UNCAUGHT UNEXCEPTION!");
    try {
      logger.error("MAIN  " + JSON.stringify(err));
    } catch (e) {
      logger.error(err);
    }
    shutdown();
    if (uncaughtCount++ > 3) { // shutdown() causing the problem?
      logger.error("MAIN  I think the shutdown procedure is borked.");
      process.exit(1);
    }
  });

process.addListener("exit", 
  function () {
    logger.info("MAIN/EXIT");
  });
